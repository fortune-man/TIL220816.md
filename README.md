# Reference
이 글은 다음을 참조하여 작성되었습니다. 감사한 마음으로 배워갑니다. 🙇🏻‍♂️

- [ISA - 위키](https://ko.wikipedia.org/wiki/명령어_집합)
- [melonicedlatte님 tistory](https://melonicedlatte.com/computerarchitecture/2019/01/30/192433.html)
- [방송대 컴퓨터과학 개론 수업](https://ucampus.knou.ac.kr/ekp/user/course/initUCRCourse.sdo?pageIndex=1&recordCountPerPage=4&sbjtId=KNOU1656001&cntsId=KNOU1656&atlcNo=9217739&tespNo=&lectPldcTocNo=&examApexNo=&burSbjtCd=&tabNo=01&dblMjSbjtYn=N&curSbjtId=&curLectPldcTocNo=&systemDiv=H&searchCntsCateNo=34&searchShgr=&searchSeme=)
- [내가 쓴 글 ㅎ](https://velog.io/@urtimeislimited/TIL-현대-컴퓨터-구조는-어디에서-온-걸까)


---

# 컴퓨터 구조 - 컴퓨터 시스템으로 연결
컴퓨터 구조를 파고들다보면 끊임없이 반복하게 되는 단어들이 있다.

"폰 노이만 모델", "명령어의 집합", "내장 프로그램"..

![지긋](https://mblogthumb-phinf.pstatic.net/MjAxNzEyMjRfMjEx/MDAxNTE0MDg1NDQxMjQ2.6pNXI84ju048713M6sEi-rIbFUqOVeyJKotDPNAaQkQg.5JiPvc_M0B2C0UnBqlkoPLW4Yxa1wLhrVi1ZlaFqSWwg.JPEG.hi_piglet/1513760045797.JPEG?type=w800)


어쩔 수 없이 하나씩 알아가야 한다. 😂

---
# 명령어 집합 구조

> ISA
- Instruction set architecture (명령어 집합 구조)
- 마이크로프로세서가 인식해서 기능을 이해하고 실행할 수 있는 기계어 명령어를 의미
- 마이크로프로세서마다 기계어 코드의 길이와 숫자 코드가 다르다. 
명령어의 각 비트는 기능적으로 분할하여 의미를 부여하고 숫자화한다. 
프로그램 개발자가 숫자(0과 1로 이루어진 숫자들)로 프로그램하기가 불편하므로 기계어와 일대일로 문자화한 것이 어셈블리어이다.

![isaImage](https://melonicedlatte.com/system/uploads/images/000/001/499/original/image.png?1548842619) 
응용 어플리케이션에서 부터 시작하여 다양한 단계를 거치게 된다.
 __중재자 역할__을 해주는 것!  



ISA는 최하위 레벨의 프로그래밍 인터페이스로, 프로세서가 실행할 수 있는 모든 명령어들을 포함한다. 
명령어 집합, 곧 명령어 집합 구조는 자료형, 명령어, 레지스터, 어드레싱 모드, 메모리 구조, 인터럽트, 예외 처리, 외부 입출력을 포함한 프로그래밍 관련 컴퓨터 아키텍처의 일부이다. 


> 아톰 프로세서
명령어 집합(ISA)를 살펴보면 IA-32, x86-64 를 사용하는 것을 볼 수 있다. 
-> 즉, 아톰 프로세서는 프로세서가 실행할 수 있는 명령어 집합을  IA-32, x86-64로 쓴다고 보면 쉽게 이해할 수 있다.

![atom-processor](https://melonicedlatte.com/system/uploads/images/000/001/500/original/image.png?1548843712)




>💡마이크로 아키텍쳐
명령어 집합 구조(ISA)를 물리적으로 구현하는 방법을 마이크로아키텍처 혹은 컴퓨터 조직이라고 하며, 
같은 명령어 집합 구조를 서로 다른 마이크로아키텍처로 구현하기도 한다. 
ex) 인텔의 펜티엄과 AMD의 애슬론, 거의 같은 명령어 집합 구조를 서로 다른 마이크로아키텍처로 구현한 것


---

### Stored program in Von-neumann-architecture

프로그램 내장 방식의 폰 노이만 구조

폰 노이만 구조의 등장으로
"데이터와 프로그램은 동일한 메모리에 저장된다."
라는 발상을 통해
데이터와 프로그램은 동일한 형태(bit-pattern)로 메모리에 표현된다는 의미를 내포하는 사고의 전환이 가능하게 되었다.

이 혁신이 가져온 결과는 다음과 같다.
>
- 범용성향상 : HW 전선을 재배치 할 필요 없이 SW만 교체 (최초의 프로그램이 내장된 컴퓨터)
- 병목현상 : 메모리에 명령어와 데이터가 함께 존재 
  - 병목현상을 없애기 위해서, 메모리 계층 구조, NUMA, 하버드 아키텍처 등과 같은 다양한 기술 및 아키텍처 등장([이전글 참조](https://velog.io/@urtimeislimited/TIL-현대-컴퓨터-구조는-어디에서-온-걸까#왜-컴퓨터-구조를-이해해야-하는가))
  
  ---
  
  컴퓨터에 대한 이해와
  
  컴퓨터 구조에 대한 이해는 
  
  컴퓨터 시스템에 대한 이해로 연결될 수 있다.
  
>컴퓨터 시스템
 - 컴퓨터 시스템이란 하나의 완전한 컴퓨터 시스템을 구성하는 4가지 요소( (하드웨어, 소프트웨어, 데이터, 사용자))이기 때문

 - 하드웨어 → 기계를 구성하고 있는 모든 물리적 기계장치 및 전자장치 → 핵심장치: 중앙처리장치(산술논리연산장치, 제어장치), 기억장치(주기억장치, 보조기억장치),입력장치, 출력장치
 - 소프트웨어 → 모든 프로그램을 총체적으로 표현하는 것 ex) 시스템 소프트웨어, 응용 소프트웨어..
 - 데이터 → 컴퓨터가 처리하는 대상으로 컴퓨터 내부에서 비트 패턴으로 변환되어 처리되며, 
  우리가 알아볼 수 있도록 적절한 변환 과정을 다시 거쳐 출력됨
 - 사용자 → 컴퓨터가 데이터를 처리하는 전반적인 과정에 다양하고 적극적인 형태로 지식과 경험이 풍부한 사람의 개입이 필요
  
 
 ---
 
 우리가 사용하는 프로그래밍 언어, 
 프레임워크와 라이브러리, 
 RDBMS 또는 ORM
 HTTP 프로토콜 등등을 사용하기 위해선
 컴퓨터가 이해할 수 있도록 알려줘야 하며,
 
 컴퓨터를 이해하기 위해선 많은 지식들과
 기술들에 대한 폭넓고 깊은 이해가 필요하고
 
 이해한 것을 기반으로 적절한 것을 골라서 효율적인 사용이 가능해야 한다.
 
 하지만 그것들을 모두 추상화 시켜보면
 결국 "어떤 문제를 해결할 것인가"
 무엇이 문제이고, 왜 하필 이것이 가장 중요한 문제인가에 대한 고민.
 가장 현명하고 올바른 방향으로 문제를 정의하는 능력이 필요하다.
 그것만이 유일하게 가장 올바른 결과를 가져올 수 있기 때문에
 
 
